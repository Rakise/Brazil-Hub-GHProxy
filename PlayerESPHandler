-- PlayerESP Otimizado para Performance Máxima
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Utils = loadstring(game:HttpGet("https://raw.githubusercontent.com/Rakise/Puppy-Hub/refs/heads/main/UtilsService"))()
local utils = Utils.new()
local ConnectionManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Rakise/Puppy-Hub/refs/heads/main/ConnectionManager"))()

-- Cache global de objetos pesados
local LocalPlayer = Players.LocalPlayer
local floor = math.floor
local format = string.format
local tick = tick
local pairs = pairs
local ipairs = ipairs

-- Cache de funções Roblox para evitar indexação repetida
local newInstance = Instance.new

-- Constantes para otimização
local UPDATE_INTERVAL = 0.5 -- Intervalo de atualização dos billboards

-- NEW: Class identification table
local classIdentify = {
	["DRUID"] = {"Perflora", "Floresco", "WiseCasting", "FastSigns"},
	["WHPSRR"] = {"Elegant Slash", "Needle's Eye", "RapierTraining", "Acrobat"},
	["D-SIGL"] = {"Dark Eruption", "Dark Flame Burst", "PlateTraining", "MercenaryCarry"},
	["SHNOBI"] = {"Grapple", "Resurrection", "FeatherFall", "UpgradedAgility"},
	["FACLES"] = {"Ethereal Strike", "Shadow Fan", "Chain Lethality", "UpgradedBane"},
	["M-NCRO"] = {"Secare", "Furantur", "WiseCasting", "FastSigns"},
	["DEEP-K"] = {"Chain Pull", "Leviathan Plunge", "FighterFootwork", "PrinceBlessing"},
	["ABYS-W"] = {"Abyssal Scream", "Wrathful Leap", "Abysswalker", "MercenaryCarry"},
	["ONI"] = {"Axe Kick", "Demon Step", "Misogi", "TrainedCombat"},
	["LPRDST"] = {"Ruby Shard", "Sapphire Shard", "Sharpener", "Gemcutter"},
	["U-BARD"] = {"Sweet Soothing", "Joyous Dance", "MusiciansResolve", "BlastMeter"},
	["M-ILUS"] = {"Globus", "Dominus", "WiseCasting", "FastSigns"},
	["SIGL-C"] = {"Charged Blow", "Hyper Body", "ChargeMastery", "PlateTraining"},
	["DSAGE"] = {"Lightning Drop", "Lightning Elbow", "MonasteryShield", "ChiBlock"},
	["DSLAYR"] = {"Thunder Spear Crash", "Dragon Blood", "FighterFootwork", "Dragon Awakening"}
}

-- NEW: Updated class colors based on new abbreviations
local class_colors = {
	["DRUID"] = "#55FF55",
	["WHPSRR"] = "#AAAAAA", -- Spy
	["D-SIGL"] = "#55557F", -- Wraith
	["SHNOBI"] = "#FFAA00", -- Shinobi
	["FACLES"] = "#FF55FF", -- Faceless
	["M-NCRO"] = "#AA0000", -- Necro
	["DEEP-K"] = "#0055AA", -- Deep
	["ABYS-W"] = "#2A0055", -- Abyss
	["ONI"] = "#FF5555",
	["LPRDST"] = "#FFAA7F", -- Smith
	["U-BARD"] = "#FFFF55", -- Bard
	["M-ILUS"] = "#AA55FF", -- Illusionist
	["SIGL-C"] = "#FF7F00", -- Sigil
	["DSAGE"] = "#55FFFF",
	["DSLAYR"] = "#FF0000", -- Slayer
	["FRESH"] = "#FFFFFF"
}

-- ADDED: Observe color
local OBSERVE_COLOR_HEX = "#55FFFF" -- Light Blue/Cyan

-- NEW: Function to get player class based on backpack/character tools
-- UPDATED: Now only checks the *first* tool in the list to act as a defining tool
local function getPlayerClass(targetPlayer)
    local backpack = targetPlayer:FindFirstChildOfClass("Backpack")
	local characterModel = targetPlayer.Character
    
    if not backpack and not characterModel then return "FRESH" end

    for classAbbr, toolList in pairs(classIdentify) do
        local definingToolName = toolList[1] -- Check ONLY the first tool
        if definingToolName then
            local foundInBackpack = backpack and backpack:FindFirstChild(definingToolName)
            local foundInCharacter = characterModel and characterModel:FindFirstChild(definingToolName)
            if foundInBackpack or foundInCharacter then
                return classAbbr -- Return as soon as the defining tool is found
            end
        end
    end

	return "FRESH"
end


-- ADDED: Function to check if a player has the Observe tool
local function hasObserveTool(targetPlayer)
    local backpack = targetPlayer:FindFirstChildOfClass("Backpack")
    local characterModel = targetPlayer.Character
    local hasInBackpack = backpack and backpack:FindFirstChild("Observe")
    local hasEquipped = characterModel and characterModel:FindFirstChild("Observe")
    return hasInBackpack or hasEquipped
end


-- Função otimizada para encontrar adornee
local function getBestAdornee(character)
    return character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChildWhichIsA("BasePart")
end

-- Configuração dos frames e labels por tabela (ADDED Held Item)
local FRAME_CONFIG = {
    {
        name = "nameFrame",
        layout = { fillDirection = Enum.FillDirection.Horizontal, horizontalAlignment = Enum.HorizontalAlignment.Center, verticalAlignment = Enum.VerticalAlignment.Center },
        labels = {
            { name = "nameLabel", key = "playerName", format = "%s", dataKey = "name", showByDefault = true, getData = function(player, cache) return player.Name end },
            { name = "distanceLabel", key = "distance", format = "[%s]", dataKey = "distance", showByDefault = true, getData = function(player, cache, localChar, targetChar)
                    if localChar and targetChar then
                        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
                        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                        if localRoot and targetRoot then return floor((localRoot.Position - targetRoot.Position).Magnitude) .. "m" end
                    end
                    return "0m"
                end } } },
    {
        name = "infoFrame",
        layout = { fillDirection = Enum.FillDirection.Horizontal, horizontalAlignment = Enum.HorizontalAlignment.Center, verticalAlignment = Enum.VerticalAlignment.Center },
        labels = {
            { name = "rogueLabel", key = "rogueName", format = "[%s]", dataKey = "rogueName", showByDefault = true, getData = function(player, cache) return utils:getPlayerRogueDisplay(player) end },
            { name = "edictLabel", key = "edict", format = "[%s]", dataKey = "edict", showByDefault = true, getData = function(player, cache) return utils:getPlayerEdictDisplay(player) end } } },
    {
        name = "hpFrame",
        layout = { fillDirection = Enum.FillDirection.Horizontal, horizontalAlignment = Enum.HorizontalAlignment.Center, verticalAlignment = Enum.VerticalAlignment.Center },
        labels = {
            { name = "hpLabel", key = "health", format = "[%s]", dataKey = "healthDisplay", showByDefault = true, getData = function(player, cache) local healthDisplay, _ = utils:getPlayerHealthDisplay(player); return healthDisplay end },
            { name = "hpPercLabel", key = "healthPercent", format = "[%s]", dataKey = "healthPercentDisplay", showByDefault = true, getData = function(player, cache) local _, healthPercentDisplay = utils:getPlayerHealthDisplay(player); return healthPercentDisplay end } } },
    {
        name = "heldItemFrame",
        layout = { fillDirection = Enum.FillDirection.Horizontal, horizontalAlignment = Enum.HorizontalAlignment.Center, verticalAlignment = Enum.VerticalAlignment.Center },
        labels = {
            { name = "heldItemLabel", key = "heldItem", format = "[Holding: %s]", dataKey = "heldItem", showByDefault = true, getData = function(player, cache, localChar, targetChar)
                    if targetChar then local equippedTool = targetChar:FindFirstChildWhichIsA("Tool"); return equippedTool and equippedTool.Name or "Nothing" end
                    return "Nothing"
                end } } }
}

local PlayerESP = {}
PlayerESP.__index = PlayerESP

function PlayerESP.new()
    local self = setmetatable({}, PlayerESP)
    self.enabled = false
    self._connMgr = ConnectionManager.new()
    self._playerConnMgrs = {}
    self.espBillboards = {}
    self.dataCache = {}
    self.displayConfig = {}
    for i, frameConfig in ipairs(FRAME_CONFIG) do
        for j, labelConfig in ipairs(frameConfig.labels) do
            local configKey = "show" .. labelConfig.key:gsub("^%l", string.upper)
            self.displayConfig[configKey] = labelConfig.showByDefault
        end
    end
    self._lastBillboardUpdate = 0
    self._localCharCache = nil
    self._localCharCacheTime = 0
    return self
end

function PlayerESP:getLocalCharacter()
    local currentTime = tick()
    if currentTime - self._localCharCacheTime > 1 then
        self._localCharCache = LocalPlayer and LocalPlayer.Character
        self._localCharCacheTime = currentTime
    end
    return self._localCharCache
end

local function createLabel(text, parent)
    local label = newInstance("TextLabel")
    label.FontSize = Enum.FontSize.Size14
    label.TextColor3 = Color3.new(1, 1, 1)
    label.Text = text
    label.TextStrokeTransparency = 0.5
    label.Font = Enum.Font.SourceSansSemibold
    label.BackgroundTransparency = 1
    label.TextSize = 14
    label.Size = UDim2.new(0, 0, 0.1, 0)
    label.AutomaticSize = Enum.AutomaticSize.X
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.RichText = true
    label.Parent = parent
    return label
end

local function createFrameWithLayout(frameName, layoutConfig, parent)
    local frame = newInstance("Frame")
    frame.Name = frameName
    frame.BackgroundTransparency = 1
    frame.Size = UDim2.new(1, 0, 0.1, 0)
    frame.Parent = parent
    local layout = newInstance("UIListLayout")
    layout.FillDirection = layoutConfig.fillDirection
    layout.HorizontalAlignment = layoutConfig.horizontalAlignment
    layout.VerticalAlignment = layoutConfig.verticalAlignment
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = frame
    return frame
end

function PlayerESP:createBillboard(player)
    local character = player.Character
    if not character or character:FindFirstChild("PlayerESP") then return end
    local adornee = getBestAdornee(character)
    if not adornee then return end
    local billboard = newInstance("BillboardGui")
    billboard.Name = "PlayerESP"
    billboard.LightInfluence = 1
    billboard.Active = true
    billboard.Adornee = adornee
    billboard.ClipsDescendants = true
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 500, 0, 100)
    billboard.Parent = adornee
    local mainLayout = newInstance("UIListLayout")
    mainLayout.Padding = UDim.new(0, 3)
    mainLayout.SortOrder = Enum.SortOrder.LayoutOrder
    mainLayout.Parent = billboard
    local billboardData = { billboard = billboard, frames = {}, labels = {} }
    for i, frameConfig in ipairs(FRAME_CONFIG) do
        local frame = createFrameWithLayout(frameConfig.name, frameConfig.layout, billboard)
        frame.LayoutOrder = i
        billboardData.frames[frameConfig.name] = frame
        for j, labelConfig in ipairs(frameConfig.labels) do
            local label = createLabel("", frame)
            label.LayoutOrder = j
            billboardData.labels[labelConfig.key] = label
        end
    end
    self.espBillboards[player] = billboardData
    self.dataCache[player] = { lastUpdate = 0 }
    self:setDisplayConfig(self.displayConfig)
    self:updatePlayerData(player)
end

function PlayerESP:removeBillboard(player)
    local data = self.espBillboards[player]
    if data and data.billboard then data.billboard:Destroy(); self.espBillboards[player] = nil end
    self.dataCache[player] = nil
end

-- Função otimizada para atualizar dados dos players
function PlayerESP:updatePlayerData(player)
    if not player or not player.Parent then return end
    local cache = self.dataCache[player]
    if not cache then return end
    local data = self.espBillboards[player]
    if not data then return end
    
    local localChar = self:getLocalCharacter()
    local targetChar = player.Character
    
    local playerClass = getPlayerClass(player)
    local classColor = class_colors[playerClass] or "#FFFFFF"
    
    -- ** Check if player has Observe tool **
    local isObserving = hasObserveTool(player)
    
    for i, frameConfig in ipairs(FRAME_CONFIG) do
        for j, labelConfig in ipairs(frameConfig.labels) do
            local label = data.labels[labelConfig.key]
            if label and labelConfig.getData then
                local value = labelConfig.getData(player, cache, localChar, targetChar)
                
                -- Determine the color to use
                local displayColor = isObserving and OBSERVE_COLOR_HEX or classColor
                
                -- Apply color override if observing
                if isObserving then
                    label.TextColor3 = Color3.fromHex(OBSERVE_COLOR_HEX) -- Set base color for non-RichText parts
                else
                    label.TextColor3 = Color3.new(1,1,1) -- Reset to white for RichText handling
                end

                -- Format text with RichText, using blue if observing
                if labelConfig.key == "playerName" then
                     -- Apply blue color to the entire line if observing
                    if isObserving then
                         label.Text = format("<font color='%s'>[%s] %s</font>", displayColor, playerClass, value)
                    else
                         label.Text = format("<font color='%s'>[%s]</font> %s", displayColor, playerClass, value)
                    end
                elseif labelConfig.key == "distance" or labelConfig.key == "rogueName" or labelConfig.key == "edict" or labelConfig.key == "health" or labelConfig.key == "healthPercent" or labelConfig.key == "heldItem" then -- FIXED TYPO HERE
                    -- Apply blue color to the entire line if observing
                     if isObserving then
                          label.Text = format("<font color='%s'>%s</font>", displayColor, labelConfig.format:format(value))
                     else
                          label.Text = labelConfig.format:format(value) -- Keep original format if not observing
                     end
                else
                    -- Fallback for any other labels
                    label.Text = labelConfig.format:format(value)
                end
            end
        end
    end
end


function PlayerESP:updateBillboards()
    local currentTime = tick()
    if currentTime - self._lastBillboardUpdate < UPDATE_INTERVAL then return end
    self._lastBillboardUpdate = currentTime
    local toRemove = {}
    for player, data in pairs(self.espBillboards) do
        if player and player.Parent and player.Character then self:updatePlayerData(player)
        else table.insert(toRemove, player) end -- Use table.insert
    end
    for i = 1, #toRemove do self:removeBillboard(toRemove[i]) end
end

function PlayerESP:connectPlayer(player)
    if player == LocalPlayer then return end
    local mgr = self._playerConnMgrs[player]
    if mgr then mgr:disconnectAll() end
    mgr = ConnectionManager.new()
    self._playerConnMgrs[player] = mgr
    mgr:add(player.CharacterAdded:Connect(function(character) if self.enabled then task.wait(0.1); self:createBillboard(player) end end))
    mgr:add(player.CharacterRemoving:Connect(function(character) self:removeBillboard(player) end))
    if player.Character then self:createBillboard(player) end
end

function PlayerESP:enable()
    self.enabled = true
    self:cleanup()
    local playerList = Players:GetPlayers()
    for i = 1, #playerList do self:connectPlayer(playerList[i]) end
    self._connMgr:add(Players.PlayerAdded:Connect(function(player) self:connectPlayer(player) end))
    self._connMgr:add(Players.PlayerRemoving:Connect(function(player) self:removeBillboard(player); local mgr = self._playerConnMgrs[player]; if mgr then mgr:disconnectAll(); self._playerConnMgrs[player] = nil end end))
    self._connMgr:add(RunService.Heartbeat:Connect(function() self:updateBillboards() end))
end

function PlayerESP:disable()
    self.enabled = false
    self:cleanup()
end

function PlayerESP:cleanup()
    self._connMgr:disconnectAll()
    for _, mgr in pairs(self._playerConnMgrs) do mgr:disconnectAll() end
    self._playerConnMgrs = {}
    for player, _ in pairs(self.espBillboards) do self:removeBillboard(player) end
    self.dataCache = {}
    self._localCharCache = nil
    self._localCharCacheTime = 0
end

function PlayerESP:setTextSize(size)
    for _, data in pairs(self.espBillboards) do for _, label in pairs(data.labels) do label.TextSize = size end end
end

function PlayerESP:setTextColor(color)
    for _, data in pairs(self.espBillboards) do for key, label in pairs(data.labels) do if key ~= "playerName" then label.TextColor3 = color end end end -- Avoid overriding playerName base color
end

function PlayerESP:setDisplayConfig(config)
    if config then for key, value in pairs(config) do self.displayConfig[key] = value end end
    for player, billboardData in pairs(self.espBillboards) do
        if billboardData and billboardData.billboard then
            local mainBillboard = billboardData.billboard
            local anyFrameVisible = false
            for i, frameConfig in ipairs(FRAME_CONFIG) do
                local frame = billboardData.frames[frameConfig.name]
                if frame then
                    local frameShouldBeVisible = false
                    for j, labelConfig in ipairs(frameConfig.labels) do
                        local configKey = "show" .. labelConfig.key:gsub("^%l", string.upper)
                        if self.displayConfig[configKey] ~= false then frameShouldBeVisible = true; break end
                    end
                    frame.Parent = frameShouldBeVisible and mainBillboard or nil
                    if frameShouldBeVisible then anyFrameVisible = true end
                end
            end
            -- mainBillboard.Enabled = anyFrameVisible -- Optional: Hide entire billboard if no content
        end
    end
end

return PlayerESP