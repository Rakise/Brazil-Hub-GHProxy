-- AutoPotion.lua
-- Module for handling automatic potion crafting, based on user-provided logic.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local AutoPotion = {}
AutoPotion.__index = AutoPotion

function AutoPotion.new()
    local self = setmetatable({}, AutoPotion)
    
    self.enabled = false
    self.isCrafting = false -- State for starting/stopping
    self.craftAmount = 1     -- Amount to craft
    self.localPlayer = Players.LocalPlayer
    
    -- Table mapping potion names to their required ingredients (from a.lua)
    self.potions = {
        ["Health Potion"] = {"Scroom", "Scroom","Lava Flower"},
        ["Tespian Elixir"] = {"Moss Plant", "Moss Plant", "Lava Flower", "Scroom"},
        ["Bone Growth"] = {"Trote", "Uncanny Tentacle", "Strange Tentacle"},
        ["Switch Witch"] = {"Dire Flower", "Glowshroom", "Glowshroom"},
        ["Silver Sun"] = {"Desert Mist", "Freeleaf", "Polar Plant"},
        ["Kingsbane"] ={"Crown Flower", "Vile Seed", "Vile Seed"},
        ["Lordsbane"] = {"Crown Flower", "Crown Flower","Crown Flower"},
        ["Feather Feet"] = {"Creely", "Dire Flower", "Polar Plant"}
    }
    
    -- List of potion names used for the UI dropdown (from a.lua)
    self.potionnames = {
        "Health Potion",
        "Tespian Elixir",
        "Bone Growth",
        "Switch Witch",
        "Silver Sun",
        "Kingsbane",
        "Lordsbane",
        "Feather Feet"
    }
    
    self.selectedPotion = "Health Potion" -- Default potion
    
    return self
end

-- Finds the closest station (e.g., "AlchemyStation") (from a.lua)
function AutoPotion:getcloseststation(stationname)
    local closest = nil
    local closestmag = 99999999999999999999
    local char = self.localPlayer.Character
    if not char then return {["Closest"] = nil, ["Distance"] = closestmag} end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {["Closest"] = nil, ["Distance"] = closestmag} end

    if Workspace:FindFirstChild("Stations") then 
        for i, v in pairs(Workspace.Stations:GetChildren()) do 
            if v.ClassName == "Model" and v:FindFirstChildOfClass("Part") and v.Name == stationname then 
                local mag = (hrp.Position - v:FindFirstChildOfClass("Part").Position).Magnitude
                if mag < closestmag then 
                    closestmag = mag
                    closest = v
                end
            end
        end
    end
    return {["Closest"] = closest, ["Distance"] = closestmag}
end

-- Renamed from makepotion() to represent a single craft attempt
-- Returns a status code
function AutoPotion:_doSingleCraft()
    local recipe = self.potions[self.selectedPotion]
    local potion = self.selectedPotion
    print("Attempting to craft: " .. potion)
    
    if not recipe then return "NO_RECIPE" end
    
    local newrec = table.clone(recipe)
    
    -- First pass: Check if player has all ingredients
    for i, v in pairs(self.localPlayer.Backpack:GetChildren()) do 
        if table.find(newrec, v.Name) and v:FindFirstChild("Quantity") then 
            local quantity = v.Quantity.Value
            repeat 
                task.wait() 
                quantity = quantity - 1
                table.remove(newrec, table.find(newrec,v.Name))
            until not table.find(newrec, v.Name)
            print("Checked Ingredient: "..v.Name..". Ingredients still needed: "..#newrec)
        end
    end
    
    -- If newrec is not empty, we are missing ingredients
    if #newrec > 0 then
        local missing = ""
        for i, v in pairs(newrec) do 
            missing = missing..v..", "
        end
        if string.sub(missing, -2) == ", " then
            missing = string.sub(missing, 1, -3)
        end
        warn("Missing Ingredients: You are missing: "..missing)
        return "MISSING_INGREDIENTS"
    end
    
    print("Ingredients Found. Proceeding with craft...")
    
    -- Second pass: Use the ingredients
    newrec = table.clone(recipe) -- Reset recipe list for use
    for i, v in pairs(self.localPlayer.Backpack:GetChildren()) do 
        if not self.isCrafting then return "CANCELLED" end -- Check if user cancelled during loop

        if table.find(newrec, v.Name) then 
            local quantity = v.Quantity.Value

            repeat 
                if not self.isCrafting then return "CANCELLED" end -- Check again
                
                task.wait()  
                quantity = quantity - 1 
                table.remove(newrec, table.find(newrec,v.Name))
                
                local char = self.localPlayer.Character
                local humanoid = char and char:FindFirstChild("Humanoid")
                
                if humanoid then 
                    humanoid:UnequipTools()
                    humanoid:EquipTool(v)
                    
                    local rem = v:FindFirstChild("RemoteEvent") 
                    local pot = self:getcloseststation("AlchemyStation")
                    task.wait(0.2) -- Increased wait after equip

                    if rem and type(pot) == "table" and pot.Closest ~= nil and pot.Distance < 10 then 
                        print("Using ingredient: " .. v.Name)
                        local args = {
                            [1] = pot.Closest.Water.CFrame,
                            [2] = pot.Closest.Water
                        }
                        rem:FireServer(unpack(args))
                        task.wait(0.2) -- Wait for server to process event
                        
                        -- If this was the last ingredient, use the ladle
                        if #newrec == 0 then 
                            print("All ingredients added. Using ladle.")
                            -- This assumes 'fireclickdetector' is a global function in your environment
                            if fireclickdetector then
                                fireclickdetector(pot.Closest.Ladle:FindFirstChildOfClass("ClickDetector"))
                            else
                                warn("fireclickdetector is not available!")
                            end
                            humanoid:UnequipTools()
                            task.wait(0.5) -- Wait for ladle animation
                        end
                    elseif pot.Distance > 10 then 
                        warn("Error: You are too far from the Alchemy Station.")
                        return "TOO_FAR" -- Stop crafting if too far
                    else
                         warn("Error: Could not find remote or station. Stopping.")
                         return "ERROR"
                    end
                else
                    warn("Error: Character or Humanoid not found. Stopping.")
                    return "ERROR"
                end 
            until not table.find(newrec, v.Name)
        end
    end
    
    return "SUCCESS"
end

-- The crafting loop that manages the queue
function AutoPotion:_craftLoop()
    for i = 1, self.craftAmount do
        if not self.isCrafting then
            print("Crafting loop interrupted by user.")
            break
        end
        
        print(string.format("Crafting potion %d of %d...", i, self.craftAmount))
        
        -- Call the single craft function
        local status
        local success, result = pcall(function() return self:_doSingleCraft() end)
        
        if not success then
            warn("An unexpected error occurred during craft:", result)
            status = "ERROR"
        else
            status = result
        end
        
        -- Handle the result
        if status == "MISSING_INGREDIENTS" or status == "TOO_FAR" or status == "ERROR" or status == "NO_RECIPE" then
            warn("Stopping craft loop due to error: " .. status)
            break
        end
        
        if status == "SUCCESS" then
            print(string.format("Successfully crafted potion %d.", i))
        end
        
        -- Wait a bit between crafts to let the server catch up
        task.wait(1) 
    end
    
    print("Crafting queue finished.")
    self.isCrafting = false
end

-- Called by the UI button
function AutoPotion:toggleCrafting()
    if self.isCrafting then
        print("Stopping crafting loop...")
        self.isCrafting = false
    else
        print("Starting crafting loop for " .. self.craftAmount .. " potions.")
        self.isCrafting = true
        task.spawn(function() self:_craftLoop() end)
    end
end

-- Called by the UI dropdown
function AutoPotion:setSelectedPotion(potionName)
    if self.isCrafting then
        warn("Cannot change potion while crafting is in progress.")
        return
    end
    self.selectedPotion = potionName
    print("Selected potion:", potionName)
end

-- Called by the UI textbox
function AutoPotion:setCraftAmount(amount)
    if self.isCrafting then
        warn("Cannot change amount while crafting is in progress.")
        return
    end
    local num = tonumber(amount) or 1
    self.craftAmount = math.max(1, num) -- Ensure at least 1
    print("Set craft amount to:", self.craftAmount)
end

-- Standard module functions
function AutoPotion:enable()
    self.enabled = true
end

function AutoPotion:disable()
    if self.isCrafting then
        self:toggleCrafting() -- Stop crafting if disabled
    end
    self.enabled = false
end

function AutoPotion:destroy()
    self:disable()
    self.potions = nil
    self.potionnames = nil
end

return AutoPotion