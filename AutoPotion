local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local AutoPotion = {}
AutoPotion.__index = AutoPotion

function AutoPotion.new()
    local self = setmetatable({}, AutoPotion)
    
    self.enabled = false
    self.isCrafting = false -- State for starting/stopping
    self.craftAmount = 1     -- Amount to craft
    self.localPlayer = Players.LocalPlayer
    
    -- Table mapping potion names to their required ingredients (from a.lua)
    self.potions = {
        ["Health Potion"] = {"Scroom", "Scroom","Lava Flower"},
        ["Tespian Elixir"] = {"Moss Plant", "Moss Plant", "Lava Flower", "Scroom"},
        ["Bone Growth"] = {"Trote", "Uncanny Tentacle", "Strange Tentacle"},
        ["Switch Witch"] = {"Dire Flower", "Glowshroom", "Glowshroom"},
        ["Silver Sun"] = {"Desert Mist", "Freeleaf", "Polar Plant"},
        ["Kingsbane"] ={"Crown Flower", "Vile Seed", "Vile Seed"},
        ["Lordsbane"] = {"Crown Flower", "Crown Flower","Crown Flower"},
        ["Feather Feet"] = {"Creely", "Dire Flower", "Polar Plant"}
    }
    
    -- List of potion names used for the UI dropdown (from a.lua)
    self.potionnames = {
        "Health Potion",
        "Tespian Elixir",
        "Bone Growth",
        "Switch Witch",
        "Silver Sun",
        "Kingsbane",
        "Lordsbane",
        "Feather Feet"
    }
    
    self.selectedPotion = "Health Potion" -- Default potion
    
    return self
end

-- Finds the closest station (e.g., "AlchemyStation") (from a.lua)
function AutoPotion:getcloseststation(stationname)
    local closest = nil
    local closestmag = 99999999999999999999
    local char = self.localPlayer.Character
    if not char then return {["Closest"] = nil, ["Distance"] = closestmag} end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {["Closest"] = nil, ["Distance"] = closestmag} end

    if Workspace:FindFirstChild("Stations") then 
        for i, v in pairs(Workspace.Stations:GetChildren()) do 
            if v.ClassName == "Model" and v:FindFirstChildOfClass("Part") and v.Name == stationname then 
                local mag = (hrp.Position - v:FindFirstChildOfClass("Part").Position).Magnitude
                if mag < closestmag then 
                    closestmag = mag
                    closest = v
                end
            end
        end
    end
    return {["Closest"] = closest, ["Distance"] = closestmag}
end

-- Renamed from makepotion() to represent a single craft attempt
-- Returns a status code
function AutoPotion:_doSingleCraft()
    local recipe = self.potions[self.selectedPotion]
    local potion = self.selectedPotion
    print("Attempting to craft: " .. potion)
    
    if not recipe then return "NO_RECIPE" end
    
    --[[
        REMOVED THE FIRST PASS.
        We will now check for ingredients one-by-one as we use them.
        This prevents trying to use items that have been destroyed.
    ]]
    
    print("Checking ingredients as we go...")
    
    -- Get character and humanoid ONCE.
    local char = self.localPlayer.Character
    local humanoid = char and char:FindFirstChild("Humanoid")
    if not humanoid then
        warn("Error: Character or Humanoid not found. Stopping.")
        return "ERROR"
    end
    
    -- Get the station ONCE.
    local pot = self:getcloseststation("AlchemyStation")
    if not pot or not pot.Closest or pot.Distance > 10 then
        warn("Error: You are too far from the Alchemy Station.")
        return "TOO_FAR"
    end
    
    -- NEW LOGIC: Iterate through the RECIPE, not the backpack.
    for i, ingredientName in ipairs(recipe) do
        if not self.isCrafting then return "CANCELLED" end -- Check if user cancelled

        -- Find a valid tool in the backpack that matches the ingredient name
        local v = self.localPlayer.Backpack:FindFirstChild(ingredientName)
        
        -- If 'v' is nil, we've run out of this ingredient.
        if not v then
            warn("Missing Ingredient: Cannot find '" .. ingredientName .. "' in backpack.")
            return "MISSING_INGREDIENTS"
        end
        
        -- We found the ingredient. Now equip and use it.
        humanoid:EquipTool(v)
        
        local rem = v:FindFirstChild("RemoteEvent") 
        task.wait(0.2) -- Increased wait after equip

        if rem then 
            print("Using ingredient: " .. v.Name)
            local args = {
                [1] = pot.Closest.Water.CFrame,
                [2] = pot.Closest.Water
            }
            rem:FireServer(unpack(args))
            -- Wait for the game to use the item and auto-unequip
            task.wait(0.3) 
        else
             warn("Error: Could not find remote on item '" .. v.Name .. "'. Stopping.")
             return "ERROR"
        end
        
        -- The loop will now continue to the next item in the recipe.
        -- If it needs "Scroom" again, it will find the *next* "Scroom" in the backpack.
    end
    
    -- If the loop finished, all ingredients were added. Now use the ladle.
    print("All ingredients added. Using ladle.")
    
    if fireclickdetector then
        local ladleDetector = pot.Closest.Ladle:FindFirstChildOfClass("ClickDetector")
        if ladleDetector then
            fireclickdetector(ladleDetector)
        else
            warn("Could not find Ladle ClickDetector!")
        end
    else
        warn("fireclickdetector is not available!")
    end
    
    -- We don't need to unequip, the game/ladle does it.
    task.wait(0.5) -- Wait for ladle animation
    
    return "SUCCESS"
end

-- The crafting loop that manages the queue
function AutoPotion:_craftLoop()
    for i = 1, self.craftAmount do
        if not self.isCrafting then
            print("Crafting loop interrupted by user.")
            break
        end
        
        print(string.format("Crafting potion %d of %d...", i, self.craftAmount))
        
        -- Call the single craft function
        local status
        local success, result = pcall(function() return self:_doSingleCraft() end)
        
        if not success then
            warn("An unexpected error occurred during craft:", result)
            status = "ERROR"
        else
            status = result
        end
        
        -- Handle the result
        if status == "MISSING_INGREDIENTS" or status == "TOO_FAR" or status == "ERROR" or status == "NO_RECIPE" then
            warn("Stopping craft loop due to error: " .. status)
            break
        end
        
        if status == "SUCCESS" then
            print(string.format("Successfully crafted potion %d.", i))
        end
        
        -- Wait a bit between crafts to let the server catch up
        task.wait(1) 
    end
    
    print("Crafting queue finished.")
    self.isCrafting = false
end

-- Called by the UI button
function AutoPotion:toggleCrafting()
    if self.isCrafting then
        print("Stopping crafting loop...")
        self.isCrafting = false
    else
        print("Starting crafting loop for " .. self.craftAmount .. " potions.")
        self.isCrafting = true
        task.spawn(function() self:_craftLoop() end)
    end
end

-- Called by the UI dropdown
function AutoPotion:setSelectedPotion(potionName)
    if self.isCrafting then
        warn("Cannot change potion while crafting is in progress.")
        return
    end
    self.selectedPotion = potionName
    print("Selected potion:", potionName)
end

-- Called by the UI textbox
function AutoPotion:setCraftAmount(amount)
    if self.isCrafting then
        warn("Cannot change amount while crafting is in progress.")
        return
    end
    local num = tonumber(amount) or 1
    self.craftAmount = math.max(1, num) -- Ensure at least 1
    print("Set craft amount to:", self.craftAmount)
end

-- Standard module functions
function AutoPotion:enable()
    self.enabled = true
end

function AutoPotion:disable()
    if self.isCrafting then
        self:toggleCrafting() -- Stop crafting if disabled
    end
    self.enabled = false
end

function AutoPotion:destroy()
    self:disable()
    self.potions = nil
    self.potionnames = nil
end

return AutoPotion